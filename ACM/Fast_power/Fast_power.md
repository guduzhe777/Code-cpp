递归关注点应该是 返回的东西的意义上  意义对了  直接放在那里就可以了



#### 求快速幂： 

1. 递归：
2. 时间复杂度log2(n)

1. 因为：b/2 每一次除以2   都是一次  b/2 /2 / 2/ 2.... 直到b= 0  可以因为  2^n = b（2^n = b 再除以 2

   就变成了 b / 2^n+1 = 0就返回了） 的时候就返回了  所以一共有 n 次 = log2(b)

a^b = a^b/2 * a^b/2 可能b为奇  会向下兼容

所以

~~~
int ret = longfastpow(a,b/2)  //这个意义就是 a为底  b/2为幂 的结果  就这样理解即可
if(b%2 == 1)
{
	return ret * ret* a;
}
~~~

#### 二进制权重更新法则：

#### 目的 ： 计算幂次？ a^b 只给你a b  取模的时候

1. 基本思路：

> ```
> ////加 减 乘  除法之前先取模  和 取模完后 加 减 乘  除法 得到一样  不信 找几个数字
> fastpowBin(ll a,ll b,ll m)   //计算  a^b 模m  a ^b 无法保存 那么 先模就行了
>         
>         
> ll fast_mulBin(ll a,ll b,ll m)
> 
> 
> //权重与二进制
> if(b&1) //二进制下含有 权重
>             {
>                // mul = (a % m) * (mul % m) ;
>                 mul =  fast_mulBin(a,mul,m);
>             }
>             b = b>>1; //b 向右移动一位 b不变  只能a变  恰好在 幂处 所以乘以自身就是 起到了 b 2 倍作用 
>             a = fast_mulBin(a,a,m);  b的每次 2倍 幂函数实现：a * a 防止溢出所以用 快速乘法  不论你对我的任何一个元素  先模还是 后模  我的整体 答案都不变 对于我 整体而言 答案都不变 
> ```

先取模  先 计算幂次乘法 都是一样的  

如果a是任何一个东西
如果：矩阵 
A^10  快速计算幂----快速幂

注意：我们目的是 拿a来乘法  我们对a的幂部 分解了 变成了

从a^(       ) = a^() * a^()  * a^()....

所以我们进行的就是这个操作 

b = b>>1   

a = a * a



所以b>>1 那么 乘法就变成 a1 a 2 a 4  所以  乘法 的a = a * a;

任何的东西的快速幂都可以

 如矩阵 

 重载* 变成矩阵乘法：

1. 矩阵乘法：：
   1. 新矩阵保存  行列乘法求和
      1. [i] [ k]  * [k] [ j ]

~~~
matrix operator*(matrix &A, matrix &B) //重载运算符
{
    matrix C(3, vi(3, 0));
    for (int i = 0; i < A.size(); i++)
    {
        for (int j = 0; j < A.size(); j++)
        {
            for (int k = 0; k < A.size(); k++)
            {
                C[i][j] += (A[i][k]* B[k][j]);  //乘法前没有溢出 每次乘法后 可能会溢出
                
            }
            C[i][j] = C[i][j];
        }
    }
    return C;
}
~~~







#### 快速幂如何进行的？!!!!

如果 

考虑对那些含1（为0的乘法为1） 的 进行 乘法  含1 的那些权重不同   

如何求呢？

b = b>>1 那么 a就来到下一个来乘法了 

恰好下一个 上一个有关系：、

​	a = a * a;

#### 应用：

计算谁的多少次方：任何都可以

如矩阵

~~~
    while (n)
    {

        if (n & 1)
        {
            B = A * B;  //矩阵乘法不会出现 溢出现象  
            // B[0][0] = B[0][0] %  mod;//每一次都对 求出来的fn取模 but每次乘法的时候矩阵中的值我都会用到 
        }
        n = n >> 1;
        A = A * A;
    }
~~~

