递归关注点应该是 返回的东西的意义上  意义对了  直接放在那里就可以了



#### 求快速幂： 

1. 递归：
2. 时间复杂度log2(n)

1. 因为：b/2 每一次除以2   都是一次  b/2 /2 / 2/ 2.... 直到b= 0  可以因为  2^n = b（2^n = b 再除以 2

   就变成了 b / 2^n+1 = 0就返回了） 的时候就返回了  所以一共有 n 次 = log2(b)

a^b = a^b/2 * a^b/2 可能b为奇  会向下兼容

所以

~~~
int ret = longfastpow(a,b/2)  //这个意义就是 a为底  b/2为幂 的结果  就这样理解即可
if(b%2 == 1)
{
	return ret * ret* a;
}
~~~

#### 二进制权重更新法则：

#### 目的 ： 计算幂次？ a^b 只给你a b  取模的时候

1. 基本思路：

> ```
> ////加 减 乘  除法之前先取模  和 取模完后 加 减 乘  除法 得到一样  不信 找几个数字
> fastpowBin(ll a,ll b,ll m)   //计算  a^b 模m  a ^b 无法保存 那么 先模就行了
>         
>         
> ll fast_mulBin(ll a,ll b,ll m)
> 
> 
> //权重与二进制
> if(b&1) //二进制下含有 权重
>             {
>                // mul = (a % m) * (mul % m) ;
>                 mul =  fast_mulBin(a,mul,m);
>             }
>             b = b>>1; //b 向右移动一位 b不变  只能a变  恰好在 幂处 所以乘以自身就是 起到了 b 2 倍作用 
>             a = fast_mulBin(a,a,m);  b的每次 2倍 幂函数实现：a * a 防止溢出所以用 快速乘法  不论你对我的任何一个元素  先模还是 后模  我的整体 答案都不变 对于我 整体而言 答案都不变 
> ```

先取模  先 计算幂次乘法 都是一样的  


如果a是任何一个东西
如果：矩阵 
A^10  快速计算幂----快速幂