## 最核心 --- 明白求的是什么 才能抓住 主要矛盾！ 明白为什么这样求！

### 过程：

~~~
	//dp数组中每个元素都代表 i个物品  j容量下 装取最大价值为多少。
    //通过前面情况最大价值 推 后续情况 最大价值：
    //dp[i][j] = max(dp[i-1][j],value[i]+dp[i-1][j-weight[i]]);
    //恰好配合 该物品要不要拿
    //最后输出  n个物品 bag 容量下 能取的最大价值
~~~







//一维dp[j]数组 

//含义：在j容量下面 放的最大价值

//初始化：dp[0] = 0,dp[j] = 0:因为max比较的时候需要被覆盖 且没有放东西价值就是0！

//递推：dp[j] = dp[j - weight[i]] + value[i],dp[j]

//:我们以物品为外循环 容量为循环

//让每一个物品看放不放进去 不放进去 那么不用更新 就是原本的值  放进去为第二个  让他们比较







有几个问题：

#### 为什么从后向前倒序呢

1. 从前面开始 会造成物品在前面用了  后面继续用不符合条件 倒序保证了前面没有用过这个物品  且 对于dp[j] + value[i] 只能用一次物品i 符合条件

#### 为什么从后向前只能装一次

1. 从前面开始 会造成物品在前面用了  后面继续用不符合条件 倒序保证了前面没有用过这个物品  且 对于dp[j] + value[i] 只能用一次物品i 符合条件

#### 为什么先用物品更新每行

1. 容量在外循环 更新的是 在j容量下 每次只拿一个物品的最大价值  

#### 为什么二维不用从后向前

1. 二维用到是左上/上方  根本不会与物品[i]相关 反倒一维 从前面开始会导致前面用到了物品i  从后面的时候 前面没有物品i相关  根本用不到

### 不断去计算覆盖 在  i个物品 在 j容量下的  最大价值