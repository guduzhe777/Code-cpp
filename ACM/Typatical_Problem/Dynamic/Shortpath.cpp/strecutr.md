//思路 到 v点最短 

cost 存储 最短

 1.判断 某个点与v是否有边

有：cost[v] 与 dfs(u) + v,u距离

没有继续判断下一个

上面创建下面用

using vi = vector<int>;

using vvi = vector<vi>;

对类重命名

cost : 

path:

if(cost[v] != INF)//INF 这句话有两种性质

未被开发  == INF

开发了 != INF 可能 会是 v点的最短距离  / 0







对于最短路径：（图可以由拓扑排序 变成线性）

cost[]保存起点到这个点的最短距离

path[]保存这个点的上一个点为多少

G[][] 保存 图的边的权重



#### 思路：

分成几份

每次都是求最短   实现？

或者说：逆向 :要求到终点 那么就先求 到上一个的距离最短   + u v之间的距离

dfs(v) 求 到v 最短距离

如何求到一个点的最短 用递归

dfs(v)



到这个点的距离：    

cost[v]>G[ i ]  [v] + dfs(i) //到i最短距离+ i 到v 

如果二者有边

对每个顶点遍历 for



递归 出去条件

? 不知道 那么先看看其他初始化

cost 默认开始最大 

除了起点 为0 

path 随便一个默认没有上一个



什么时候出去呢？ 返回什么呢  

如果到起点 那么 返回 起点到起点最短距离

如果某个点到起点 的最短距离  已经确定  存在 cost[v]  那么之间返回

所以 cost 不是 初始化的值 返回最短距离；





#### 几个点：

1. 写法：

   1. 如果要求最短距离 不妨保存的地方 给初值 INF = 0x3f3f3f3f

   2. 模板：

      1. 为模板重命名 using v1 = vector<int>;  以后v1 当作 类型用

         1. using vv1 = vector<v1>;

         2. 为模板整体赋值 ： 

            1. cost = v1(vex, INF); 

            2. ~~~
               using vv1 = vector<v1>;
               vv1	G;
               G = vector<n,v1(vex,0)>
               ~~~

            3. 我们设置一个全局变量 可以被任何 函数改变  也可以被任何函数使用

               1. ~~~
                  v1 cost
                  
                  
                  int main:
                  	cost = v1(n,INF); 初始化为 n个INF 这就是模板赋值  之间 = 模板类型( , )
                  ~~~

         3. 写法：

            1. 抓住：cost path G dfs  有边的含义 如何 判断最短距离
            2. cost  开始默认 最短距离 默认赋值INF 无穷大   确定起点 起点cost[v] = 0;
            3. path 最短距离 该点的上一个点 默认-1   反正没有上一个点  初始化了
            4. G 二维数组保存权重 正好  开始为 0 /INF都可以 等待输入 也就是看有没有边：
            5. 有边：G[ ] [ ] 有值
            6. 递归写法  每次都是求最短距离  有边参与计算 更新到这个点的最短距离 开始最短距离：INF

