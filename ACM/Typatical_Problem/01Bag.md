//一维dp[j]数组 

//含义：在j容量下面 放的最大价值

//初始化：dp[0] = 0,dp[j] = 0:因为max比较的时候需要被覆盖 且没有放东西价值就是0！

//递推：dp[j] = dp[j - weight[i]] + value[i],dp[j]

//:我们以物品为外循环 容量为循环

//让每一个物品看放不放进去 不放进去 那么不用更新 就是原本的值  放进去为第二个  让他们比较







有几个问题：

#### 为什么从后向前倒序呢

1. 从前面开始 会造成物品在前面用了  后面继续用不符合条件 倒序保证了前面没有用过这个物品  且 对于dp[j] + value[i] 只能用一次物品i 符合条件

#### 为什么从后向前只能装一次

1. 从前面开始 会造成物品在前面用了  后面继续用不符合条件 倒序保证了前面没有用过这个物品  且 对于dp[j] + value[i] 只能用一次物品i 符合条件

#### 为什么先用物品更新每行

1. 容量在外循环 更新的是 在j容量下 每次只拿一个物品的最大价值  

#### 为什么二维不用从后向前

1. 二维用到是左上/上方  根本不会与物品[i]相关 反倒一维 从前面开始会导致前面用到了物品i  从后面的时候 前面没有物品i相关  根本用不到