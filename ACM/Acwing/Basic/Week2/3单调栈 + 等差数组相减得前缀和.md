



### 分析题目

根据题目
快乐数组 即 以i为左定端点  s[j] - s[i] 始终 连续 大于0 的部分

引出  用集合 符合 即 集合内全部 都 符合 思想
求集合 子集元素的和  发现 等差数列。

引出1 若找到最后一个满足的边界点下标，求集合的全部子集和即可


引出2 求等差数列的前缀和
因为：等差数列性质：方差相同  做差 相同
便 等差数列1 * 前缀和 - 等差数列2 * 前缀和 = c * 一维前缀和

$a[j]>=a[i](满足条件) =>a[j]<a[i] (求不满足条件)  => a[i]>a[j](以i为定点) $
求左定点i  右边 第一个j  $a[i] >a[j] $

### 单调栈

~~~
单调栈求序列左/右边 第一个 最大/最小元素的信息 如 下标
求左边最小： 
目的：x>stk[top]
左边栈紧贴
找栈小 x已近 若 再小则 栈顶舍
若x>stk[top] 目的达到
将x 加入栈 保证紧贴


求右边最小，紧贴 x已经最近 若还小 那么 栈顶舍 找了 对应下标即可；


对于求其他信息：
明确求什么  和stk[top] 含义 
对于此题 stk[top] 是紧贴 ai的栈顶元素对应的下标 
求a[i]>a[j] j的值  还是!!!右边最小!!!
a[i]已经最近，若a[i]还小 则 stk[top] 下标对应的元素不再需要 top--
即： a[i]<=stk[top] top--

标记：
对于从左边看 即 左边紧贴
top为0栈中没有元素 左边没有比他大/小的值

右边来看 即 右边紧贴

~~~



### 等差数列前缀和

~~~
集合的子集和为等差数列前缀和 

变成了 

等差数列前缀和 对应项相减 = c * 一维前缀和

~~~

