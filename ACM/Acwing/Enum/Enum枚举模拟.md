## 1219. 移动距离  核心为 值 对应坐标 求得行列  及 坐标的曼哈顿距离

1. 距离 不依靠数字值  而依靠相对距离，将原数组减一  先处理  那么

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 11   | 10   | 9    | 8    | 7    | 6    |
| 12   | 13   | 14   | 15   | 16   | 17   |

从0开始 使得 n / w 就是行数  而不会出现  6 / 6 = 1这个异类

n % w 恰好为列数

数值与下标对应 真是个好东西

2. 两种距离
   1. 曼哈顿距离 $|x(1)-x(2)| + |y(1) -  y(2)|$  求折线上的距离   其中x y为坐标！！！
   2. 欧几里得距离:几何距离
3. 1. n % w为顺序坐标   逆序坐标如何求？ 
      1. w - 1 - n % w 即可
4. 余下为 坐标的曼哈顿距离

## 1229  日期问题  从数据对应年月日  变成了 枚举所有值  判断是否合法

1. 分析：

   1. 比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。

      年月日   月日年  日月年  三种情况

      1960   2059  范围     19  / 20 两种选择 在  范围内

      两种选择 

   2. 字符串和整形数字的转化，太繁琐了呀！

   3. 枚举 1960 01 01 ---- 2059 12 31 10^6 而已  舍弃了一大丢条件

2. 写法：

   1. scanf  printf  有格式的（%d %s） 输入0输  scanf("%d/%d/%d",&a,&b,&c);将 a b c读出来

   2. printf有格式的输出

      1. ~~~
         printf("%d-%02d-%02d\n",year,mouth,day);//前面补0 占两位 
         printf("%d-%-02d-%-02d\n",year,mouth,day);//负号代表后面d但是只有 前面可以补0  且 其他补位不行只能补0
         ~~~

      2. 

   3. 日期判断

      1. ~~~
         int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
         bool check_Valid(int year,int mouth,int day)
         {
             if(mouth<=0||mouth>12) return false;//月
             if(!day) return false;//日
             if(mouth != 2&&day > days[mouth]) return false;//日
             if(mouth == 2)//闰年二月
             {
                 int leap = year % 4 == 0&&year % 100 != 0||year % 400 == 0;//闰年 多一天 加到下面28里面
                 if(day>28 + leap) return false;
             }
             return true;
         }
         ~~~

      2. 

      



