## 1219. 移动距离  核心为 值 对应坐标 求得行列  及 坐标的曼哈顿距离

1. 距离 不依靠数字值  而依靠相对距离，将原数组减一  先处理  那么

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 11   | 10   | 9    | 8    | 7    | 6    |
| 12   | 13   | 14   | 15   | 16   | 17   |

从0开始 使得 n / w 就是行数  而不会出现  6 / 6 = 1这个异类

n % w 恰好为列数

数值与下标对应 真是个好东西

2. 两种距离
   1. 曼哈顿距离 $|x(1)-x(2)| + |y(1) -  y(2)|$  求折线上的距离   其中x y为坐标！！！
   2. 欧几里得距离:几何距离
3. 1. n % w为顺序坐标   逆序坐标如何求？ 
      1. w - 1 - n % w 即可
4. 余下为 坐标的曼哈顿距离

## 1229  日期问题  从数据对应年月日  变成了 枚举所有值  判断是否合法

1. 分析：

   1. 比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。

      年月日   月日年  日月年  三种情况

      1960   2059  范围     19  / 20 两种选择 在  范围内

      两种选择 

   2. 字符串和整形数字的转化，太繁琐了呀！

   3. 枚举 1960 01 01 ---- 2059 12 31 10^6 而已  舍弃了一大丢条件

2. 写法：

   1. scanf  printf  有格式的（%d %s） 输入0输  scanf("%d/%d/%d",&a,&b,&c);将 a b c读出来

   2. printf有格式的输出

      1. ~~~
         printf("%d-%02d-%02d\n",year,mouth,day);//前面补0 占两位 
         printf("%d-%-02d-%-02d\n",year,mouth,day);//负号代表后面d但是只有 前面可以补0  且 其他补位不行只能补0
         ~~~

      2. 

   3. 日期判断

      1. ~~~
         int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
         bool check_Valid(int year,int mouth,int day)
         {
             if(mouth<=0||mouth>12) return false;//月
             if(!day) return false;//日
             if(mouth != 2&&day > days[mouth]) return false;//日
             if(mouth == 2)//闰年二月
             {
                 int leap = year % 4 == 0&&year % 100 != 0||year % 400 == 0;//闰年 多一天 加到下面28里面
                 if(day>28 + leap) return false;
             }
             return true;
         }
         ~~~

      2. 

      

### 1231. 航班时间

基本：时区问题： 东早西晚 （东边跑在西边前面）  所以 西到东加时差  东到  ： 西 + 时差（东边的时间 ） - 东 

~~~
3
17:48:19 21:57:24
11:05:18 15:14:23
17:21:07 00:31:46 (+1)
23:02:41 16:13:20 (+1)
10:19:19 20:41:24
22:19:04 16:41:09 (+1)
~~~



1. 题目分析：

   1. 给的时间为  开始  结束时间  得到绝对时间  

      time11，time21西  time12 time22东

      $time11 + dh - time12 == 绝对时间$ 

      $time22 - dh  - time21 = 绝对时间$

      求出来两个进行加法:$time11 + time22  - time12 -time 21 = 2 * 绝对时间$

   2. 无法计算的 字符串 转化

      1. 利用格式对齐 统一换成整数型 

         1. ~~~
            sscanf(str,格式);
            sscanf(time_str1.c_str(),"%d:%d:%d %d:%d:%d (+%d)",&h1,&m1,&s1,&h2,&m2,&s2,&d);
            ~~~

   3. 统一换成整数型 转化成 秒统一对时间计算

   4. 时间转化：

      1. ~~~
         int get_second(int h,int m,int s)
         {
             return h * 3600 + m * 60 + s;//返回秒数
         }
          int h0 = second0 / 3600,m0 = second0 % 3600 / 60,s0 = second0 % 60;//3600 变成1h  含3600 最后变成一小时 
          //同理：将一小时对应完毕后 含60变成一分钟  总是这样
          //最后模60  余下 秒
         ~~~

   5. 细节：

      1. ~~~
         scanf输入完后 getchar() 防止 回车干扰 字符串问题切记！！！
         ~~~

### 1241. 外卖店优先级



 N 家外卖店，编号 1∼N 

经过 1 个时间单位 没有订单，则优先级会减少 1 有订单	优先级加 2。

优先级大于 5  加入优先缓  小于等于 3		清除出优先缓存。



 T时刻以内的 M 条订单信息

输入

N 店数量  , M 个变化  ,T T时刻什么情况

 M行 每行包含两个整数 ts 和 id，表示 ts时刻编号 id 的外卖

1. 暴力 ：
   1. 数组存储 到底有几个订单 且消除有序情况！！！  直接变成了  ts时刻 的时候 id商家有几个订单   我们遍历到T  就是T时刻即可 ！！！
2. 优化



### 788. 逆序对的数量  在归并 （分治思想）同时 查看逆序对数量 前面排完序后 后续 找到那个 q[i]>q[j] 则 后续q[i] 都大于 q[j] 

1. 过程：
   1. 先分  分到最后一个 返回 两个 时候 进行逆序对求解  排序   等待返回res   排序 同时  找寻q[i] >q[j] 找到了 res 直接等于 mid - i + 1  找不到自然的排序  
2. 细节：res += mid - i + 1 
   1. 上一个 l  mid   mid + 1   r 求的res   +   我这次新的 l mid   mid + 1 r  对应  res  才是整个序列的res！！ 
   2. 为什么归并排序复杂度为$n * log(n)$（  $T(n)$含义 分治 排序 长度为n的序列 时间复杂度）
   3. $ T(n) = T(n/2) + T(n/2) + o(n) $-->>>>>$2 * (2 * T(n/4) + O(n))+o(n) $--->>>$2^k(T(n/2^k) + o(n/2^k))+o(n) $
   4. 到了最后 序列为1 时候   $n/2^k = 1$  所以$k = log(n)$  所以 复杂度 $n * log(n)$
