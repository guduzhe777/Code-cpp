大思路：前缀表达式  

从前到后扫描

分别两种情况 

1. 数字

   1. 分为四种情况

      1. 数字前一位 也是数字 

         1. 那么 进位

         2. ~~~
            double pow = 10;  //对应   num是对应s[i]的值
                        num = s[i] - '0'; //原本为字符//都会等于 第一个数字 等待 判断前面为 什么
                        我想说的是 num = s[i] 对这个值保存都是这一次都是围绕他进行的
                        换成下一个值 那么 围绕就变成了下一个  pow对于每一个s[] 都是一样 10  就是为了防止前面有数字
            ~~~

         3. 

      2. 数字前一位 为小数点

         1. 降位 如果有小数点 那么 前一位 如果是数字权重一定为 1

         2. ~~~
            				num /= pow;
                                pow = 1;
                                
            ~~~

         3. 

      3. 数字前一位 空格

         1. 直接放进即可

      4. 数字前一位为-号

         1. num = -num 变成负的放进去

   2. 在前面操作完  然后  放入栈顶

2. 符号

   1. 从栈顶拿出来元素

   2. 进行switch 选择运算放到栈顶 最后输出

      1. switch 用符号写开关  最后添加break结束

      2. ~~~~
         switch (s[i])
                     {
                     case '+':
                         sum = a + b;
                         break;}
                         
         ~~~~

   3. 特殊情况：

      1. 除法 下面为0：

      2. ~~~
         if (b == 0)
                         {
                             cout << "ERROR";
                             return 0;
                         }
         ~~~

      3. 元素s[i] pow 含义作用 决定了 他们什么时候更新
         1. 对应实际物理模型：一个元素  
      4. 双循环 i--  既可以 访问元素  且访问完元素就走了 牛逼！

      

      

2 * 3 - 7 4 / 8 4

符号后面一定有>=两个数字



~~~
isdigit(s[i])是否十进制数字

num = s[i] - '0'; 我们存的字符  以后当成数字来运算的 需要变成数字！！

for i-- 用于 指向一个元素
    {
        if (isdigta(s[i]))
        {
            double pow = 10;  //对应   num是对应s[i]的值
            num = s[i] - '0'; /
            for i-- 用于 判断该元素的前一个元素  
		}
		
	}	
	
	
	一趟循环下来 即压入栈顶 又改变指针
~~~







2 * 3 - 7 4 / 8 4

​    9+9-8

getline(cin, s); 从cin中提取字符 到s中

 

a = st.pop();  返回指针

b = st.top();  取栈顶元素

 switch (s[i])直接赋值符号

switch 后续跟着break不要忘记

~~~
switch (s[i])
            {
            case '+':
                sum = a + b;
                break;
~~~

