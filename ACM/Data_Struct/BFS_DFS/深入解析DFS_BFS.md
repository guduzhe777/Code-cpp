我们在图中举例

栈/队列 + 邻接表 探索未被探索的邻接点  放到栈/队列中等待处理。

：当提起栈有了模样

~~~
f.push(x);//你能想到一个点一个点放进去后 基于栈 他们是如何被遍历的么
~~~

~~~
f.push(x);//能想到一个一个点被放进去 如何 遍历的么
~~~



：当提起邻接表探索未被探索的邻接点，有了动作

~~~
Edge* e = npool[nu].first;//探索所有邻接点
while(e != NULL)			//探索所有邻接点 --"所有！"
	if(npool[e->v].mark == 0)//未被探索的点
		f.push(e->v);
		npool[e->v].mark = 1;//被探索
	e = e->next;//探索所有邻接点
~~~



DFS 与 BFS合起来说

点集X（被处理的点） 与 点集 F（等待被探索的点）

【这个为栈/队列】

先放入一个点 处理这个点 从F中拿出来（放到x中） 

用这个点  将 连接的点 放到 探索里面，等待探索



以上就是DFS  BFS基本的操作，一个点 处理  这个点 引出的点 放到F中。

**这个F序列如何取为关键**

若F为栈----先进后出  后进先出

----------------------------------------------------------------------------------------------------------

引出一个点 连接点 放到F中 那么 他 会一直取栈顶元素 

即：这个引出的点的点 一直逮住不放；直到该点 周围点全部被处理/无连接点 

回溯 处理 该点  的 邻居

----------------------------------------------------------------------------------------------------------

若F为队列----先进先出 后进后出

----------------------------------------------------------------------------------------------------------

放入一个点 到 F中

将该点所有连接点 全部放入 

将每一个点连接点 放入 队列中 处理完 上级的每一个后 再处理 他及他的邻居，上级邻居的下级们 

若有个点无连接点/未处理点 则不放入即可；直到 未处理点集为空；

----------------------------------------------------------------------------------------------------------



DFS_递归版本

----------------------------------

点集x：是否被处理 obs[i] = true;//i点被处理

DFS（v） 访问v的所有出边

若v的连接点 未被处理 处理他 （这里处理是看你需要什么操作）

继续看他的连接点直到 空 

回溯 继续上级的下一条出边。

