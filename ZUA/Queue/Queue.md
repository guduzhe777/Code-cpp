#### 头进头出 所以会用到双指针  头部  尾部

1. 头部 尾部同时在开头

2. 入队 ： 尾部操作 ++（%n）

3. 出队：头部操作（++）%n

4. top == tail
   1. //当尾部和头部指向同一个地方 这样是不行的 那么空怎么判断呢 所以空 为 top == tail
5. top == （tail + 1）% n  指针相差一个位置那么就被认为满了 + 先到位置再赋值  所以会空出来一个
   1. 满了 相邻  不会再增加了    保证了  除非空 不然不会重合 
   1. 
6. 好吧更改写法：始终指向空的地方等待插入 以后都是 指针先放到位置然后赋值

始终指向一个元素/

始终指向空的地方等待插入

空的标准就是 tail == top

满的标准： tail + 1 == top  最后一个不写了（指针事先到达 + 判断满 基于(tail + 1 ) % n== top）到了最后一个元素 就以为满了  与top相隔一个地址 那么就满了  top == tail 这是重合的特征

~~~
int Isfull()
    {
        if(（Tail + 1）%n == Top)   //当尾部和头部 相差一个 （满了不会再增加保证 除了空不会重合）
        {
            return 1;
        }
        return 0;
    }
~~~

1. 为什么会空出来一个元素
   1. 指针先过去  然后 再等待下一次赋值  + 判断是否为满 基于 ( tail + 1 ) % n == top 指针相差一个位置 那么 就是满了  恰好尾指针 对应位置没有赋值
2. 循环队列和队列有什么不同
   1. 储存：队列当个线性表就行  不会回头   循环队列还要%n
   2. 代码写法：循环队列时刻考虑 top tail 这些指向队列元素的指针 是否会越过n 所以时刻需要%n
